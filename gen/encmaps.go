//go:generate go run . -base ../base2048.txt -tail ../tail.txt -output ../default_encoding.go

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

func readRunes(path string, num int) ([]rune, error) {
	bytes, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err //nolint:wrapcheck
	}

	str := string(bytes)
	str = strings.NewReplacer("\r", "", "\n", "").Replace(str)
	runes := []rune(str)

	if len(runes) != num {
		//nolint:goerr113
		return nil, fmt.Errorf(
			"in %s: The number of characters should be %d, but %d",
			path,
			num,
			len(runes),
		)
	}

	return runes, nil
}

func main() {
	base2048File := flag.String("base", "base2048.txt", "base2048 chars file name")
	tailFile := flag.String("tail", "tail.txt", "tail chars file name")
	outputFile := flag.String("output", "decode_map.go", "output file name")
	flag.Parse()

	base2048Runes, err := readRunes(*base2048File, 2048)
	if err != nil {
		log.Panic(err)
	}

	tailRunes, err := readRunes(*tailFile, 8)
	if err != nil {
		log.Panic(err)
	}

	v := struct {
		Base2048File string
		TailFile     string
		Encoder      []rune
		Trailing     []rune
	}{
		filepath.Base(*base2048File),
		filepath.Base(*tailFile),
		base2048Runes,
		tailRunes,
	}

	var buf bytes.Buffer
	err := template.Must(template.New("output").Parse(output)).Execute(&buf, v)
	if err != nil {
		log.Panic(err)
	}

	data, err := imports.Process(*outputFile, buf.Bytes(), nil)
	if err != nil {
		log.Panic(err)
	}

	err = ioutil.WriteFile(*outputFile, data, 0o644)
	if err != nil {
		log.Panic(err)
	}
}

const output = `
// Code generated by encmaps.go; DO NOT EDIT.
// Based on information from {{.Base2048File}} and {{.TailFile}}

package base2048

// Default map table for encoder.
var DefaultEncodeChars = []rune {
{{range .Encoder}}	{{. | printf "0x%x"}},
{{end}}}

// Default map table for trailing.
var DefaultTrailingChars = []rune {
{{range .Trailing}}	{{. | printf "0x%x"}},
{{end}}}
`
